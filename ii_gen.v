//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? ?? 29 2018 17:08:31
//
//      Input file      : 
//      Component name  : ii_gen
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module ii_gen(clk, reset, start, image_scale, image_data_i, ii_data_i, iix2_data_i, mem_state, scaleImg_x_base, scaleImg_y_base, image_rdaddress, ii_address, ii_wren, ii_data_o, iix2_data_o, done);
   input            clk;
   input            reset;
   input            start;
   input [3:0]      image_scale;
   input [11:0]     image_data_i;
   input [19:0]     ii_data_i;
   input [27:0]     iix2_data_i;
   input            mem_state;
   input [8:0]      scaleImg_x_base;
   input [7:0]      scaleImg_y_base;
   output [16:0]    image_rdaddress;
   output [12:0]    ii_address;
   output           ii_wren;
   output [19:0]    ii_data_o;
   output [27:0]    iix2_data_o;
   output           done;
   
   
   parameter   II_WIDTH = 6'd39;
   parameter   II_HEIGHT = 6'd59;
   
   wire [7:0]       grey_data;	//灰度数据
   wire [15:0]      grey_data_square;		//灰度方
   
   wire [15:0]      temp0;
   wire [15:0]      temp1;
   wire [16:0]      temp3;
   wire [16:0]      scaleImg_address_base;
   wire [16:0]      image_address_base;		//基地址
   wire [20:0]      temp_image_address_base;	//临时建立图像基地址
   
   reg [12:0]       ii_address;		//输出地址
   
   reg [5:0]        x;
   reg              x_count_reset;
   reg              x_count_en;
   
   reg [5:0]        y;
   reg              y_count_reset;
   reg              y_count_en;
   
   reg              ii_address_sel;
   reg [12:0]       ii_wraddress;	//写地址
   wire [12:0]      ii_rdaddress;	//读地址
   reg [16:0]       image_rdaddress_s;	//图片读地址
   reg              address_accum_reset;
   reg              buffer_we;
   
   reg              accum_reset;
   reg              accum_en;
   reg [13:0]       ii_data_accum;
   reg [21:0]       iix2_data_accum;
   wire [13:0]      add2;
   wire [21:0]      add3;
   wire [19:0]      add2_extend;
   wire [27:0]      add3_extend;
   wire [19:0]      add4;
   wire [27:0]      add5;
   
   reg [19:0]       ii_data_o_s;
   reg [27:0]       iix2_data_o_s;
   
   reg              done_s;
   
   parameter [2:0]  STATE_TYPE_s_RESET = 0,
                    STATE_TYPE_s_latch_RAM_read = 1,
                    STATE_TYPE_s_latch_RAM_write = 2,
                    STATE_TYPE_s_soft_reset = 3,
                    STATE_TYPE_s_DONE = 4;
   reg [2:0]        state;
   reg [2:0]        next_state;
   
   //parameter [11:0] my_lut0[0:8] = {0, ((320 * 1 - (39 - 1) * 1)), ((320 * 2 - (39 - 1) * 2)), ((320 * 3 - (39 - 1) * 3)), ((320 * 4 - (39 - 1) * 4)), ((320 * 5 - (39 - 1) * 5)), ((320 * 6 - (39 - 1) * 6)), ((320 * 7 - (39 - 1) * 7)), ((320 * 8 - (39 - 1) * 8))};
   
	wire 	[8:0]	my_lut0;
	
	assign		my_lut0[0:0]= 12'd0,
				my_lut0[1:1]= 12'd282,
				my_lut0[2:2]= 12'd564,
				my_lut0[3:3]= 12'd846,
				my_lut0[4:4]= 12'd1128,
				my_lut0[5:5]= 12'd1410,
				my_lut0[6:6]= 12'd1692,
				my_lut0[7:7]= 12'd1974,
				my_lut0[8:8]= 12'd2256;
	

	wire [11:0]      lut0_q;
   
   reg              pipeline_reset;
   reg              pipeline_advance;
   
   reg [5:0]        reg0_x;
   reg [5:0]        reg0_y;
   reg [12:0]       reg0_ii_wraddress;
   reg [11:0]       reg0_image_data;
   reg [19:0]       reg0_ii_data;
   reg [27:0]       reg0_iix2_data;
   reg              reg0_accum_reset;
   reg              reg0_accum_en;
   reg              reg0_done;
   reg [5:0]        reg1_x;
   reg [5:0]        reg1_y;
   reg [12:0]       reg1_ii_wraddress;
   reg [7:0]        reg1_grey_data;
   reg [19:0]       reg1_ii_data;
   reg [27:0]       reg1_iix2_data;
   reg              reg1_accum_reset;
   reg              reg1_accum_en;
   reg              reg1_done;
   reg [5:0]        reg2_x;
   reg [5:0]        reg2_y;
   reg [12:0]       reg2_ii_wraddress;
   reg [7:0]        reg2_grey_data;
   reg [15:0]       reg2_grey_data_square;
   reg [19:0]       reg2_ii_data;
   reg [27:0]       reg2_iix2_data;
   reg              reg2_accum_reset;
   reg              reg2_accum_en;
   reg              reg2_done;
   reg [5:0]        reg3_x;
   reg [5:0]        reg3_y;
   reg [12:0]       reg3_ii_wraddress;
   reg [19:0]       reg3_add2_extend;
   reg [27:0]       reg3_add3_extend;
   reg [19:0]       reg3_add4;
   reg [27:0]       reg3_add5;
   reg              reg3_done;
   
   reg              reset_done_reg;
   reg              done_reg;
   
   
   always @(posedge clk )
   begin
      if (x_count_reset == 1'b1)
         x <= 6'b0;
      else if (x_count_en == 1'b1)
         x <= x + 6'd1;
   end
   
   
   always @(posedge	clk)
   begin
      if (y_count_reset == 1'b1)
         y <= 6'b0;
      else if (y_count_en == 1'b1)
         y <= y + 6'd1;
   end
   
   
   RGB2GREY RGB2GREY_inst(
   .Din(reg0_image_data), 
   .Dout(grey_data)
   );
   assign grey_data_square = (reg1_grey_data * reg1_grey_data);
   
   assign temp0 = {scaleImg_y_base, 8'b00000000};
   assign temp1 = {2'b00, scaleImg_y_base, 6'b000000};
   assign temp3 = (({1'b0, temp0}) + ({1'b0, temp1}));
   assign scaleImg_address_base = (temp3 + scaleImg_x_base);
   
   assign temp_image_address_base = (scaleImg_address_base * image_scale);
   assign image_address_base = temp_image_address_base[16:0];
   
   assign lut0_q = my_lut0[image_scale];
   
   
   always @(posedge	clk)
   begin
      if (address_accum_reset == 1'b1)
         image_rdaddress_s <= image_address_base;
      else if (x_count_en == 1'b1)
         image_rdaddress_s <= image_rdaddress_s + image_scale;
      else if (y_count_en == 1'b1)
         image_rdaddress_s <= image_rdaddress_s + lut0_q;
   end
   assign image_rdaddress = image_rdaddress_s;
   
   
   always @(posedge	clk )
   begin
      if (address_accum_reset == 1'b1)
      begin
         if (mem_state == 1'b0)
            ii_wraddress <= 13'b0;
         else
            ii_wraddress <= 13'd4096;
      end
      else if (x_count_en == 1'b1 | y_count_en == 1'b1)
         ii_wraddress <= ii_wraddress + 1'd1;
   end
   
   assign ii_rdaddress = (ii_wraddress - II_WIDTH);
   
   
   always @(posedge	clk)
   begin
      if (ii_address_sel == 1'b0)
         ii_address <= ii_rdaddress;
      else
         ii_address <= reg3_ii_wraddress;
   end
   
   assign add2 = (reg2_grey_data + ii_data_accum);
   assign add3 = (reg2_grey_data_square + iix2_data_accum);
   assign add2_extend[19:14] = 6'b0;
   assign add2_extend[13:0] = add2;
   assign add3_extend[27:22] = 6'b0;
   assign add3_extend[21:0] = add3;
   
   
   always @(posedge	clk)
   begin
      if ((reg2_accum_reset == 1'b1) & (pipeline_advance == 1'b1))
      begin
         ii_data_accum <= 14'b0;
         iix2_data_accum <= 22'b0;
      end
      else
         if ((reg2_accum_en == 1'b1) & (pipeline_advance == 1'b1))
         begin
            ii_data_accum <= add2;
            iix2_data_accum <= add3;
         end
   end
   
   assign add4 = (reg2_ii_data + add2);
   assign add5 = (reg2_iix2_data + add3);
   
   
   always @(posedge	clk)
   begin
      if (reg3_y == 6'b000000)
      begin
         ii_data_o_s <= reg3_add2_extend;
         iix2_data_o_s <= reg3_add3_extend;
      end
      else
      begin
         ii_data_o_s <= reg3_add4;
         iix2_data_o_s <= reg3_add5;
      end
   end
   
   
   always @(posedge	clk )
   begin
      if (pipeline_reset == 1'b1)
      begin
         reg0_x <= 6'b0;
         reg0_y <= 6'b0;
         reg0_ii_wraddress <= 13'b0;
         reg0_image_data <= 12'b0;
         reg0_ii_data <= 20'b0;
         reg0_iix2_data <= 28'b0;
         reg0_accum_reset <= 1'b1;
         reg0_accum_en <= 1'b0;
         reg0_done <= 1'b0;
         
         reg1_x <= 6'b0;
         reg1_y <= 6'b0;
         reg1_ii_wraddress <= 13'b0;
         reg1_grey_data <= 8'b0;
         reg1_ii_data <= 20'b0;
         reg1_iix2_data <= 28'b0;
         reg1_accum_reset <= 1'b1;
         reg1_accum_en <= 1'b0;
         reg1_done <= 1'b0;
         
         reg2_x <= 6'b0;
         reg2_y <= 6'b0;
         reg2_ii_wraddress <= 13'b0;
         reg2_grey_data_square <= 16'b0;
         reg2_ii_data <= 20'b0;
         reg2_iix2_data <= 28'b0;
         reg2_accum_reset <= 1'b1;
         reg2_accum_en <= 1'b0;
         reg2_done <= 1'b0;
         
         reg3_x <= 6'b0;
         reg3_y <= 6'b0;
         reg3_ii_wraddress <= 13'b0;
         reg3_add2_extend <= 20'b0;
         reg3_add3_extend <= 28'b0;
         reg3_add4 <= 20'b0;
         reg3_add5 <= 28'b0;
         reg3_done <= 1'b0;
      end
      
      else if (pipeline_advance == 1'b1)
      begin
         reg0_x <= x;
         reg0_y <= y;
         reg0_ii_wraddress <= ii_wraddress;
         reg0_image_data <= image_data_i;
         reg0_ii_data <= ii_data_i;
         reg0_iix2_data <= iix2_data_i;
         reg0_accum_reset <= accum_reset;
         reg0_accum_en <= accum_en;
         reg0_done <= done_s;
         
         reg1_x <= reg0_x;
         reg1_y <= reg0_y;
         reg1_ii_wraddress <= reg0_ii_wraddress;
         reg1_grey_data <= grey_data;
         reg1_ii_data <= reg0_ii_data;
         reg1_iix2_data <= reg0_iix2_data;
         reg1_accum_reset <= reg0_accum_reset;
         reg1_accum_en <= reg0_accum_en;
         reg1_done <= reg0_done;
         
         reg2_x <= reg1_x;
         reg2_y <= reg1_y;
         reg2_ii_wraddress <= reg1_ii_wraddress;
         reg2_grey_data <= reg1_grey_data;
         reg2_grey_data_square <= grey_data_square;
         reg2_ii_data <= reg1_ii_data;
         reg2_iix2_data <= reg1_iix2_data;
         reg2_accum_reset <= reg1_accum_reset;
         reg2_accum_en <= reg1_accum_en;
         reg2_done <= reg1_done;
         
         reg3_x <= reg2_x;
         reg3_y <= reg2_y;
         reg3_ii_wraddress <= reg2_ii_wraddress;
         reg3_add2_extend <= add2_extend;
         reg3_add3_extend <= add3_extend;
         reg3_add4 <= add4;
         reg3_add5 <= add5;
         reg3_done <= reg2_done;
      end
   end
   
   
   always @(posedge clk or posedge	reset )
   begin
      if (reset == 1'b1)
         state <= STATE_TYPE_s_RESET;
      else 
         state <= next_state;
   end
   
   
   always @(posedge clk or posedge	reset)
   begin	
   	  if	(reset ==1'b1)begin
      accum_reset <= 1'b0;
      buffer_we <= 1'b0;
      accum_en <= 1'b0;
      x_count_reset <= 1'b0;
      x_count_en <= 1'b0;
      y_count_reset <= 1'b0;
      y_count_en <= 1'b0;
      done_s <= 1'b0;
      ii_address_sel <= 1'b0;
      address_accum_reset <= 1'b0;
      pipeline_advance <= 1'b0;
      pipeline_reset <= 1'b0;
      reset_done_reg <= 1'b0;
      end
    else case (state)
         STATE_TYPE_s_RESET :
            begin
               accum_reset <= 1'b1;
               address_accum_reset <= 1'b1;
               x_count_reset <= 1'b1;
               y_count_reset <= 1'b1;
               pipeline_reset <= 1'b1;
               reset_done_reg <= 1'b1;
               if (start == 1'b1)
                  next_state <= STATE_TYPE_s_latch_RAM_read;
               else
                  next_state <= STATE_TYPE_s_RESET;
            end
         
         STATE_TYPE_s_latch_RAM_read :
            begin
               ii_address_sel <= 1'b0;
               next_state <= STATE_TYPE_s_latch_RAM_write;
            end
         
         STATE_TYPE_s_latch_RAM_write :
            begin
               pipeline_advance <= 1'b1;
               buffer_we <= 1'b1;
               ii_address_sel <= 1'b1;
               
               if (x == II_WIDTH - 1)
               begin
                  accum_reset <= 1'b1;
                  if (y == II_HEIGHT - 1)
                  begin
                     done_s <= 1'b1;
                     next_state <= STATE_TYPE_s_DONE;
                  end
                  else
                  begin
                     y_count_en <= 1'b1;
                     next_state <= STATE_TYPE_s_soft_reset;
                  end
               end
               else
               begin
                  accum_en <= 1'b1;
                  x_count_en <= 1'b1;
                  next_state <= STATE_TYPE_s_latch_RAM_read;
               end
            end
         
         STATE_TYPE_s_soft_reset :
            begin
               x_count_reset <= 1'b1;
               next_state <= STATE_TYPE_s_latch_RAM_read;
            end
         
         STATE_TYPE_s_DONE :
            begin
               if (done_reg == 1'b1)
                  ;
               else
               begin
                  ii_address_sel <= 1'b1;
                  pipeline_advance <= 1'b1;
                  buffer_we <= 1'b1;
               end
               next_state <= STATE_TYPE_s_DONE;
            end
      endcase
   end
   
   
   always @(posedge	clk )
   begin
      if (reset_done_reg == 1'b1)
         done_reg <= 1'b0;
      else if (reg3_done == 1'b1)
         done_reg <= 1'b1;
   end
   
   assign ii_wren = buffer_we;
   assign ii_data_o = ii_data_o_s;
   assign iix2_data_o = iix2_data_o_s;
   assign done = done_reg;
   
endmodule
