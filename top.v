//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? ?? 29 2018 17:20:54
//
//      Input file      : 
//      Component name  : top
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------

// Project: Viola Jones Face Detection on FPGA : 4/8/2016
// Project done using Quartus II 15.1 and tested on DE2-115
//
// Contributing Members:
//   Dr. Cristinel Ababei
//   Peter Irgens
//   Curtis Bader
//   Theresa Le
//   Devansh Saxena
// 
// System Specifications
//   Capture Resolution: 320x240
//   Scales: 1-4
// 
// General Theory of Opperation:
//  The top level of this design consists of a number of major components.
//  This includes:
//   (1) top level state machine and misc. behavioral logic
//   (2) ov7670 camera controller and capture entities
//   (3) image frame buffer
//   (4) integral image frame buffers
//   (5) integral image generator
//   (6) parallel subwindow top level
//   (7) faceBox record container/ box generator
//   (8) VGA related entities
//  
//  The top level state machine coordinates the sequential execution from image capture to drawing boxes on detected faces.
//  ov7670 entities are responsible for configuring the complex register set of the ov7670 camera peripheral and capturing frames from the camera.
//  The image frame buffer stores the current image that is to be processed by the face detection subsystems and  is overwritten with red boxes where faces are detected.
//  The integral image generator converts portions of the original color image to greyscale and then to integral image (ii) and integral image squared (iix2) format 
//   which is then stored in respective integral image buffers.
//  Each integral image (ii and iix2) is duplicated such that, since the high bit width dual port RAM implementation is not addressable by individual words, 16 words plus the
//   adjacent 16 words in the integral image can be read at the same time such that any 16 word chunk can be fed to the subwindow as necessary in the same memory read operation.
//  If this was not implemented, the first 16 words would need to be registered and then the second 16 words would then be read on a second read cycle, thus taking two memory read cycles to
//   facilitate one lump data transfer to 16 parallel subwindows.
//  The current implementatoin utilizes redundant embedded RAM for integral images, but facilitates less clock cycles for one full 16 subwindow memory read operation.
//  It is important to minimize the number of clock cycles for subwindow memory read operations since this eats up most of the systems total execution time.
//  Note that future optimizations should revolve around speeding up these memory read operations.
//  The parallel subwindow top level is a container for the the state machine process, global classifier cascade parameters, and the 16 subwindows that enable
//   concurrent evaluation of feature arithmatic.
//  Failure flags are asserted from the subwindow entities if non faces are detected within the respective subwindow locations and if at least one subwindow passed does not
//   assert a failure then the detection result is logged by faceBox.
//  FaceBox has a dual port RAM entity that facilitates storage of the current image scale, coordinate of the top left corner of subwindow0 and the detection result of all 16 subwindows.
//  FaceBox also contains a state machine process that writes red boxes to the image buffer for logged face detections. This process is executed once all images are processed in the image pyramid.
//  
//  
//  See code for more details.

module top(
   clk_100,
   slide_sw_RESET,
   //slide_sw_resend_reg_values,
   slide_sw_capture_mode,
   btn_capture,
   LED_config_finished,
   //LED_dll_locked,
   
   HDMI1_CLK_P,
   HDMI1_CLK_N,
   HDMI1_D2_P, 
   HDMI1_D2_N, 
   HDMI1_D1_P, 
   HDMI1_D1_N, 
   HDMI1_D0_P, 
   HDMI1_D0_N, 
   
   HDMI2_CLK_P,
   HDMI2_CLK_N,
   HDMI2_D2_P, 
   HDMI2_D2_N, 
   HDMI2_D1_P, 
   HDMI2_D1_N, 
   HDMI2_D0_P, 
   HDMI2_D0_N, 
   
   
   
   ov7670_pclk,
   ov7670_xclk,
   ov7670_vsync,
   ov7670_href,
   ov7670_data,
   ov7670_sioc,
   ov7670_siod,
   
   
   
   ii_gen_done,
   subwin_done,
   faceBox_done,
   //measure_performance
);
   input              clk_100;		//100Mhz
   input                slide_sw_RESET;		// reset the whole animal; SW17
   //input                slide_sw_resend_reg_values;		// rewrite all OV7670's registers; SW16
   input                slide_sw_capture_mode;		// '0'= video mode, '1'=button capture mode; sw15
   input                btn_capture;		// logic '0' input when pressed; KEY0
   
   output               LED_config_finished;		// lets us know camera registers are now written; -- LEDR1
   //output               LED_dll_locked;		// PLL is locked now; -- LEDR0
   
//   output               vga_hsync;
//   output [7:0]         vga_r;
//   output [7:0]         vga_g;
//   output [7:0]         vga_b;
//   output               vga_blank_N;
//   output               vga_sync_N;
   //HDMI_1
   output HDMI1_CLK_P;
   output HDMI1_CLK_N;
   output HDMI1_D2_P;
   output HDMI1_D2_N;
   output HDMI1_D1_P;
   output HDMI1_D1_N;
   output HDMI1_D0_P;
   output HDMI1_D0_N;
   //HDMI_2 
   output HDMI2_CLK_P;
   output HDMI2_CLK_N;
   output HDMI2_D2_P;
   output HDMI2_D2_N;
   output HDMI2_D1_P;
   output HDMI2_D1_N;
   output HDMI2_D0_P;
   output HDMI2_D0_N;
   
   
  
  (*mark_debug="true"*)    input                ov7670_pclk;
  (*mark_debug="true"*)   output               ov7670_xclk;
  (*mark_debug="true"*)   input                ov7670_vsync;
  (*mark_debug="true"*)   input                ov7670_href;
  (*mark_debug="true"*)   input [7:0]          ov7670_data;
  (*mark_debug="true"*)   output               ov7670_sioc;
  (*mark_debug="true"*)   inout                ov7670_siod;

   
   
   output               ii_gen_done;		// GPIO[35], debug
   output               subwin_done;		// GPIO[29], debug
   output               faceBox_done;		// GPIO[27], debug
   
   //output               measure_performance;		// GPIO[34], toggles after every faceBox process completion ... so half period on o-scope is indicates the processed FPS
   
   
   // constants
   parameter    		II_WIDTH =6'd39		;
   parameter       		II_HEIGHT=6'd59		;
  
  	//other_debug
 (*mark_debug="true"*)   	wire           measure_performance;
  	
  	//OV7670
 (*mark_debug="true"*)   	wire	 ov7670_pwdn;
  	
  	//HDMI
  	wire pixclk;
  	wire pixclk_X5;
 (*mark_debug="true"*) 		wire DE;
 (*mark_debug="true"*)   	wire[23:0]  RGB;
  	assign RGB={vga_r ,vga_g ,vga_b };
  	wire lock;
    
   wire               vga_hsync;   
   wire               vSync;
   wire [7:0]         vga_r;       
   wire [7:0]         vga_g;       
   wire [7:0]         vga_b;       
   //wire               vga_blank_N; 
   wire               vga_sync_N;  
  
  
  
  
   // clock signals
   wire                 clk_50_camera;
   wire                 clk_25_vga;
   wire                 clk_sys;
   wire                 clk_iigen;
   wire                 clk_faceBox;
  // wire                 dll_locked;
   
   // user controls;
   wire                 reset;
   wire                 resend_reg_values;
   wire                 capture_mode;
   wire                 capture;
   
   // buffer signals
 (*mark_debug="true"*)   reg                  buff_1A_mux_sel = 0;
 (*mark_debug="true"*)   reg                  buff_1B_mux_sel = 0;
 (*mark_debug="true"*)   wire [16:0]          address_buff_1A;
 (*mark_debug="true"*)   wire [16:0]          address_buff_1B;
   wire                 clk_buff_1A;
   wire                 clk_buff_1B;
(*mark_debug="true"*)   wire [11:0]          rddata_buff_1A;
(*mark_debug="true"*)   wire [11:0]          rddata_buff_1B;
   
(*mark_debug="true"*)   wire                 wren_buff_2A;		//ram1ะด
 (*mark_debug="true"*)  wire [12:0]          address_buff_2A;
(*mark_debug="true"*)   wire [19:0]          wrdata_buff_2A;
(*mark_debug="true"*)   wire [19:0]          rddata_buff_2A;
 (*mark_debug="true"*)  wire [8:0]           address_buff_2B;
 (*mark_debug="true"*)  wire [8:0]           address_buff_2B_prime;
(*mark_debug="true"*)   wire [(16*20*2)-1:0] rddata_buff_2B;		// 16 subwindows, 20bit wide words, 2 ram entities connected
   
   wire                 wren_buff_3A;
   wire [12:0]          address_buff_3A;
   wire [27:0]          wrdata_buff_3A;
   wire [27:0]          rddata_buff_3A;
   wire [8:0]           address_buff_3B;
   wire [8:0]           address_buff_3B_prime;
   wire [(16*28*2)-1:0] rddata_buff_3B;		// 16 subwindows, 28bit wide words, 2 ram entities connected
   
   // integral image related
   reg                  next_mem_state ;
   reg                  mem_state = 0;
   reg [8:0]            next_ii_gen_x_base;
   reg [8:0]            ii_gen_x_base = 9'b0;
   reg [7:0]            next_ii_gen_y_base ;
   reg [7:0]            ii_gen_y_base = 8'b0;
   wire [16:0]          image_rdaddress_from_iigen;		// when in ii_gen mode, rd address comes from ii_gen
   reg                  ii_gen_start_s = 0;
   reg                  ii_gen_reset_s = 0;
   wire                 ii_gen_done_s;
   
   // subwindow related
   wire [15:0]          subwin_fail_s;
   reg                  subwin_any_fail = 0;
   reg                  subwin_all_fail = 0;
   reg [8:0]            next_subwin_x_base;
   reg [8:0]            subwin_x_base = 9'b0;
   reg [7:0]            next_subwin_y_base;
   reg [7:0]            subwin_y_base = 8'b0;
   reg [5:0]            next_subwin_x_base_offset;
   reg [5:0]            subwin_x_base_offset = 6'b0;
   reg [5:0]            next_subwin_y_base_offset;
   reg [5:0]            subwin_y_base_offset = 6'b0;
   wire [8:0]           subwin_x_pos;
   wire [7:0]           subwin_y_pos;
   reg                  subwin_start_s = 0;
   wire                 subwin_done_s;
   reg                  subwin_reset_s = 0;
   
   // RGB related
   wire [7:0]           red;
   wire [7:0]           green;
   wire [7:0]           blue;
   wire                 activeArea;
   wire                 nBlank;

   
   // capture related
   reg                  take_snapshot;
   wire [16:0]          image_wraddress_from_ov7670_capture;
   wire [11:0]          image_wrdata_from_ov7670_capture;
   wire                 image_wren_from_ov7670_capture;
   wire                 ov7670_capture_busy;
   
   // faceBox related
   wire [16:0]          image_wraddress_from_faceBox;
   wire [11:0]          image_wrdata_from_faceBox;
   wire                 image_wren_from_faceBox;
   reg                  faceBox_start_s;
   wire                 faceBox_done_s;
   wire                 faceBox_wren;
   reg                  faceBox_reset_s;
   
   // VGA related
   wire [16:0]          image_rdaddress_from_addr_gen;		// when in video mode, rd address comes from address_generator
   
   // top level state machine
   parameter [3:0]      STATE_TYPE_s_RESET = 0,		//
                        STATE_TYPE_s_CAPTURE_start = 1,
                        STATE_TYPE_s_CAPTURE = 2,
                        STATE_TYPE_s_newScale_RESET = 3,
                        STATE_TYPE_s_ii_gen_init = 4,
                        STATE_TYPE_s_subwin_RESET = 5,
                        STATE_TYPE_s_ii_gen_subwin_RESET = 6,
                        STATE_TYPE_s_ii_gen_subwin = 7,
                        STATE_TYPE_s_scale = 8,
                        STATE_TYPE_s_faceBox_start = 9,
                        STATE_TYPE_s_faceBox = 10;
   reg [3:0]            current_state;
   reg [3:0]            next_state;
   
   // image size and position signals
   reg [3:0]            scale_count;
   reg                  scale_count_en;
   reg                  scale_count_reset;
   wire [8:0]           width_scale_img;		// assigned lut0
   wire [7:0]           height_scale_img;		// assigned lut1
   
   // scale image width lookup table
  // parameter [0:8]  my_lut0[0:8] = {0, 320, 160, 107, 80, 64, 54, 46, 40};		// scale 0 not used
   
   // scale image height lookup table
  // parameter [0:8]  my_lut1[0:8] = {0, 240, 120, 80, 60, 48, 40, 35, 30};		// scale 0 not used
   
   	wire	[8:0]	my_lut0;
 assign  my_lut0[0:0]= 9'd0,
		 my_lut0[1:1]= 9'd320,
		 my_lut0[2:2]= 9'd160,
		 my_lut0[3:3]= 9'd107,
		 my_lut0[4:4]= 9'd80,
		 my_lut0[5:5]= 9'd64,
		 my_lut0[6:6]= 9'd54,
		 my_lut0[7:7]= 9'd46,
		 my_lut0[8:8]= 9'd40;
				
	
    wire	[8:0]	my_lut1	;
 assign	my_lut1[0:0]= 9'd0 ,
		my_lut1[1:1]= 9'd240,
		my_lut1[2:2]= 9'd120,
		my_lut1[3:3]= 9'd80,
		my_lut1[4:4]= 9'd60,
		my_lut1[5:5]= 9'd48,
		my_lut1[6:6]= 9'd40,
		my_lut1[7:7]= 9'd35,
		my_lut1[8:8]= 9'd30;		  
	
	reg                  measure_performance_reg = 0;
   
   // inputs
   assign reset = slide_sw_RESET;
   assign capture_mode = slide_sw_capture_mode;
   assign capture = (~btn_capture);		// invert button assertion logic
   
   // scale counter and associated height/width lookup tables
  reg [2:0]            num; 
   always @(posedge	clk_sys )
   begin
      if (scale_count_reset == 1'b1)
         num = 1;		// begin at scale=1
      else if ( scale_count_en == 1'b1)
         num = num + 1'b1;		// increment to the next scale
      scale_count <= num;
   end   
   assign width_scale_img = my_lut0[scale_count];
   assign height_scale_img = my_lut1[scale_count];
   
   
   // determine if subwindows all fail or only some fail
   
   always @(subwin_fail_s)
   begin
      subwin_any_fail <= subwin_fail_s[0] | subwin_fail_s[1] | subwin_fail_s[2] | subwin_fail_s[3] | subwin_fail_s[4] | subwin_fail_s[5] | subwin_fail_s[6] | subwin_fail_s[7] | subwin_fail_s[8] | subwin_fail_s[9] | subwin_fail_s[10] | subwin_fail_s[11] | subwin_fail_s[12] | subwin_fail_s[13] | subwin_fail_s[14] | subwin_fail_s[15];
   end
   
   
   always @(subwin_fail_s)
   begin
      subwin_all_fail <= subwin_fail_s[0] & subwin_fail_s[1] & subwin_fail_s[2] & subwin_fail_s[3] & subwin_fail_s[4] & subwin_fail_s[5] & subwin_fail_s[6] & subwin_fail_s[7] & subwin_fail_s[8] & subwin_fail_s[9] & subwin_fail_s[10] & subwin_fail_s[11] & subwin_fail_s[12] & subwin_fail_s[13] & subwin_fail_s[14] & subwin_fail_s[15];
   end
   
   // TOP LEVEL STATE MACHINE
   
   //---------- state machine flip flop ------
   
   
   always @(posedge clk_sys or posedge reset)begin
      if (reset == 1'b1) begin
         current_state <= STATE_TYPE_s_RESET;
         mem_state <= 1'b0;
         subwin_x_base_offset <= 6'b0;
         subwin_y_base_offset <= 6'b0;
         ii_gen_x_base <= 9'b0;
         ii_gen_y_base <= 8'b0;
         subwin_x_base <= 9'b0;
         subwin_y_base <= 8'b0;
      end 
      else  begin
         current_state <= next_state;
         mem_state <= next_mem_state;
         subwin_x_base_offset <= next_subwin_x_base_offset;
         subwin_y_base_offset <= next_subwin_y_base_offset;
         ii_gen_x_base <= next_ii_gen_x_base;
         ii_gen_y_base <= next_ii_gen_y_base;
         subwin_x_base <= next_subwin_x_base;
         subwin_y_base <= next_subwin_y_base;
      end 
   end
   //---------- state machine combinational logic -------
   
   
   always @(posedge	clk_sys		)   begin
  	  begin
      buff_1A_mux_sel <= 1'b0;
      buff_1B_mux_sel <= 1'b0;
      subwin_reset_s <= 1'b0;
      subwin_start_s <= 1'b0;
      faceBox_start_s <= 1'b0;
      faceBox_reset_s <= 1'b0;
      ii_gen_start_s <= 1'b0;
      ii_gen_reset_s <= 1'b0;
      scale_count_reset <= 1'b0;
      scale_count_en <= 1'b0;
      take_snapshot <= 1'b0;
      next_mem_state <= mem_state;
      next_subwin_x_base_offset <= subwin_x_base_offset;
      next_subwin_y_base_offset <= subwin_y_base_offset;
      next_ii_gen_x_base <= ii_gen_x_base;
      next_ii_gen_y_base <= ii_gen_y_base;
      next_subwin_x_base <= subwin_x_base;
      next_subwin_y_base <= subwin_y_base;
      end
    case (current_state)
         STATE_TYPE_s_RESET :
            begin
               subwin_reset_s <= 1'b1;
               faceBox_reset_s <= 1'b1;
               scale_count_reset <= 1'b1;
               ii_gen_reset_s <= 1'b1;
               next_mem_state <= 1'b0;
               next_subwin_x_base_offset <= 6'b0;
               next_subwin_y_base_offset <= 6'b0;
               next_ii_gen_x_base <= 9'b0;
               next_ii_gen_x_base <= 9'b0;
               next_subwin_x_base <= 9'b0;
               next_subwin_y_base <= 8'b0;
               next_state <= STATE_TYPE_s_CAPTURE_start;
            end
         
         // continuously capture individual frames or capture continuously in video mode
         STATE_TYPE_s_CAPTURE_start :
            if (ov7670_capture_busy == 1'b1)		// wait until camera capture controller begins
               next_state <= STATE_TYPE_s_CAPTURE;
            else begin
               if (capture_mode == 1'b0)		// video mode
                  take_snapshot <= 1'b1;
               else
                  if (capture == 1'b1)		// capture single frame, until capture button is released
                     take_snapshot <= 1'b1;
               next_state <= STATE_TYPE_s_CAPTURE_start;
            end
         
         // wait until frame is captured
         STATE_TYPE_s_CAPTURE :
            if (ov7670_capture_busy == 1'b0)
               next_state <= STATE_TYPE_s_newScale_RESET;
            else
               next_state <= STATE_TYPE_s_CAPTURE;
         
         // perform soft reset before processing the new scale image
         STATE_TYPE_s_newScale_RESET :
            begin
               // make sure ii_gen and subwindow are reset
               ii_gen_reset_s <= 1'b1;
               subwin_reset_s <= 1'b1;
               // next ii_gen process will store the initial integral image in the lower part of the integral image buffer
               next_mem_state <= 1'b0;
               // make sure that ii_gen and subwindow location registers are reset to scaled image (0,0) position
               next_subwin_x_base <= 9'b0;
               next_subwin_y_base <= 8'b0;
               next_ii_gen_x_base <= 9'b0;
               next_ii_gen_y_base <= 8'b0;
               next_subwin_x_base_offset <= 6'b0;
               next_subwin_y_base_offset <= 6'b0;
               next_state <= STATE_TYPE_s_ii_gen_init;
            end
         
         // process the initial integral image
         STATE_TYPE_s_ii_gen_init :
            if (ii_gen_done_s == 1'b1) begin		// wait until  the ii_gen process completes
               // advance integral image base for next ii_gen process (relative to the current scale image)
               next_ii_gen_x_base <= 9'b0;
               next_ii_gen_y_base <= 8'd36;		// offset by number of vertical subwindow scans per integral image = II_HEIGHT-SUBWIN_DIM+1 =59-24+1=36
               next_state <= STATE_TYPE_s_ii_gen_subwin_RESET;
            end else begin
               ii_gen_start_s <= 1'b1;		// start the ii_gen process
               buff_1B_mux_sel <= 1'b1;		// mux ii_gen clock and generated rdaddress to image buffer portB
               next_state <= STATE_TYPE_s_ii_gen_init;
            end
         
         // subwindow only reset
         STATE_TYPE_s_subwin_RESET :
            begin
               buff_1B_mux_sel <= 1'b1;
               subwin_reset_s <= 1'b1;
               if (subwin_any_fail == 1'b1)		// dont start until all subwindow fail flags are reset
                  next_state <= STATE_TYPE_s_subwin_RESET;
               else
                  next_state <= STATE_TYPE_s_ii_gen_subwin;
            end
         
         // ii_gen and subwindow reset, also invert integral image memeory state
         STATE_TYPE_s_ii_gen_subwin_RESET :
            begin
               buff_1B_mux_sel <= 1'b1;
               ii_gen_reset_s <= 1'b1;
               subwin_reset_s <= 1'b1;
               if (subwin_any_fail == 1'b1)		// dont start until all subwindow fail flags are reset
                  next_state <= STATE_TYPE_s_ii_gen_subwin_RESET;
               else begin
                  next_mem_state <= (~mem_state);		// invert integral image memeory state
                  next_state <= STATE_TYPE_s_ii_gen_subwin;
               end
            end
         
         // generate the next integral image by scanning the ii_gen process through the scaled image,
         // and scan the parallel subwindows through the current integral image
         STATE_TYPE_s_ii_gen_subwin :
            begin
               next_subwin_x_base_offset <= 6'b0;		// base address of subwindow is always zero relative to current integral dimentions
               buff_1B_mux_sel <= 1'b1;
               
               ii_gen_start_s <= 1'b1;		// start ii_gen process
               subwin_start_s <= 1'b1;		// start subwin process
               
               // when the current classifier cascade finishes or all subwindows fail
               if (subwin_done_s == 1'b1 | subwin_all_fail == 1'b1) begin
                  
                  // scan all possible subwindow areas in the current integral image
                  if ((subwin_y_base_offset < (II_HEIGHT - 24)) & (subwin_y_base_offset < (height_scale_img - 24))) begin
                     next_subwin_y_base_offset <= subwin_y_base_offset + 6'b1;		// subwin_y_base_offset+=1
                     next_state <= STATE_TYPE_s_subwin_RESET;		// only restart subwindow
                  end else
                     
                     // increment integral image location when the subwindows scan through all locations within the current integral image
                     // and ii_gen has generated the next integral image for subwindow evaluation	
                     if (ii_gen_done_s == 1'b1) begin
                        next_subwin_y_base_offset <= 6'b0;		// reset
                        next_subwin_x_base <= ii_gen_x_base;		// update subwindow cascade base index with old ii_gen base index
                        next_subwin_y_base <= ii_gen_y_base;
                        
                        // scan all possible integral image areas in the current scaled image
                        if (({1'b0, ii_gen_y_base}) < (({1'b0, height_scale_img}) - ({1'b0, II_HEIGHT}))) begin
                           next_ii_gen_y_base <= ii_gen_y_base + 8'd36;		// ii_gen_y_base +=36
                           next_state <= STATE_TYPE_s_ii_gen_subwin_RESET;		// restart subwindow process and integral image process
                        end else
                           if (({1'b0, ii_gen_x_base}) < (({1'b0, width_scale_img}) - ({1'b0, II_WIDTH}))) begin
                              next_ii_gen_x_base <= ii_gen_x_base + 9'd16;		// ii_gen_x_base += 16
                              next_ii_gen_y_base <= 8'b0;		// ii_gen_y_base = 0 ; async reset
                              next_state <= STATE_TYPE_s_ii_gen_subwin_RESET;		// restart subwindow process and integral image process
                           end else
                              // done with image process at the current scale
                              next_state <= STATE_TYPE_s_scale;
                     end else
                        
                        // ii_gen process is not done, wait until done
                        next_state <= STATE_TYPE_s_ii_gen_subwin;
               end else
                  // cascade still processing
                  next_state <= STATE_TYPE_s_ii_gen_subwin;
            end
         
         // increment the image scale
         STATE_TYPE_s_scale :
            begin
               subwin_reset_s <= 1'b1;
               ii_gen_reset_s <= 1'b1;
               if (scale_count == 4'b1000)		// first 4 scales implemented
                  next_state <= STATE_TYPE_s_faceBox_start;
               else begin
                  scale_count_en <= 1'b1;		// increment scale
                  next_state <= STATE_TYPE_s_newScale_RESET;
               end
            end
         
         // start the faceBox process
         STATE_TYPE_s_faceBox_start :
            begin
               faceBox_start_s <= 1'b1;
               next_state <= STATE_TYPE_s_faceBox;
            end
         
         // wait until the faceBox process is done
         STATE_TYPE_s_faceBox :
            begin
               buff_1A_mux_sel <= 1'b1;
               if (faceBox_done_s == 1'b1)
                  next_state <= STATE_TYPE_s_RESET;
               else begin
                  faceBox_start_s <= 1'b1;
                  next_state <= STATE_TYPE_s_faceBox;
               end
            end
      endcase
   end
   
   // clocks generation;
   
   my_altpll Inst_four_clocks_pll(
      .reset(reset),		// reset_general?
      .clk_in1(clk_100),		//100MHz
      .clk_out1(clk_sys),		// 40MHz   
      .clk_out2(clk_50_camera),		// 50MHz
      .clk_out3(pixclk),     // output 74.25
      .clk_out4(pixclk_X5), 		//371.25      
      .locked()		// drives an LED;
   );
   assign clk_faceBox = clk_sys;
   //assign LED_dll_locked = dll_locked;
   assign  clk_iigen = clk_100;
   
   
   // debouncing slide switches;
   // take entity input slide_sw_resend_reg_values and debounce it to
   // get clean resend_reg_values signal;
   
   debounce Inst_debounce_resend(
      .clk(pixclk),
      .i(slide_sw_RESET),
      .o(resend_reg_values)
   );
   
   // camera module related 
   
   ov7670_controller Inst_ov7670_controller(
      .clk(clk_50_camera),
      .resend(resend_reg_values),		// debounced;
      .config_finished(LED_config_finished),		// LEDRed[1] notifies user;
      .sioc(ov7670_sioc),
      .siod(ov7670_siod),
      .pwdn(ov7670_pwdn),
      .xclk(ov7670_xclk)
   );
   
   
   ov7670_capture Inst_ov7670_capture(
      .pclk(ov7670_pclk),		//in
      .capture(take_snapshot),	//in
      .vsync(ov7670_vsync),		//in
      .href(ov7670_href),		//in
      .d(ov7670_data),			//in
      .addr(image_wraddress_from_ov7670_capture),	//out
      .dout(image_wrdata_from_ov7670_capture),		//out
      .we(image_wren_from_ov7670_capture),			//out
      .busy(ov7670_capture_busy)					//out
   );
   
   // VGA related
   
   Address_Generator Inst_Address_Generator(
      .rst_i(1'b0),
      .CLK25(pixclk),
      .enable(activeArea),
      .vsync(vSync),
      .address(image_rdaddress_from_addr_gen)
   );
   
   hdmi_display_0  u_hdmi_display_0
(
    .PXLCLK_I          (pixclk),
    .PXLCLK_5X_I       (pixclk_X5),
    .LOCKED_I          (lock),
    .RST_N             (lock),
    .VGA_RGB           (RGB),
    .VGA_HS            (vga_hsync),
    .VGA_VS            (vSync),
    .VGA_DE            (DE),
    .HDMI_CLK_P        (HDMI1_CLK_P),
    .HDMI_CLK_N        (HDMI1_CLK_N),
    .HDMI_D2_P         (HDMI1_D2_P),
    .HDMI_D2_N         (HDMI1_D2_N),
    .HDMI_D1_P         (HDMI1_D1_P),
    .HDMI_D1_N         (HDMI1_D1_N),
    .HDMI_D0_P         (HDMI1_D0_P),
    .HDMI_D0_N         (HDMI1_D0_N)
);
   
   hdmi_display_0  u_hdmi_display_1
(
   // .i2c_clk            (i2c_clk),
    .PXLCLK_I            (pixclk),
    .PXLCLK_5X_I         (pixclk_X5),
    .LOCKED_I           (lock),
    .RST_N              (lock),
    .VGA_RGB             (RGB),
    .VGA_HS           (vga_hsync),
    .VGA_VS           (vSync),
    .VGA_DE              (DE),
    .HDMI_CLK_P        (HDMI2_CLK_P),
    .HDMI_CLK_N        (HDMI2_CLK_N),
    .HDMI_D2_P         (HDMI2_D2_P),
    .HDMI_D2_N         (HDMI2_D2_N),
    .HDMI_D1_P         (HDMI2_D1_P),
    .HDMI_D1_N         (HDMI2_D1_N),
    .HDMI_D0_P         (HDMI2_D0_P),
    .HDMI_D0_N         (HDMI2_D0_N)
);
   

   
   VGA Inst_VGA(
      .CLK25(pixclk),
      .Hsync(vga_hsync),
      .Vsync(vSync),
      .Nblank(nBlank),
      .Nsync(vga_sync_N),
      .activeArea(activeArea),
  	  .VGA_DE (DE)
   
   );
   
   
   RGB Inst_RGB(
      .Din(rddata_buff_1A),
      .Nblank(activeArea),
      .R(red),
      .G(green),
      .B(blue)
   );
   
   assign vga_r = red[7:0];
   assign vga_g = green[7:0];
   assign vga_b = blue[7:0];
//   assign vga_blank_N = nBlank;
   
   // Image Frame Buffer Setup: Stores 12bit color data for conversion to integral image and vga display
   //   write port A : faceBox
   //   write port B : camera capture
   //   read port A : VGA
   //   read port B : ii_gen
   
   image_frame_buffer image_ram1(
      .addra(address_buff_1A),
      .addrb(address_buff_1B),
      .clka(clk_buff_1A),
      .clkb(clk_buff_1B),
      .dina(image_wrdata_from_faceBox),
      .dinb(image_wrdata_from_ov7670_capture),
      .ena(image_wren_from_faceBox),
      .wea(1'b1),
      .web(1'b1),
      .enb(image_wren_from_ov7670_capture),
      .douta(rddata_buff_1A),//VGA
      .doutb(rddata_buff_1B)//ii_gen
   );
   
   // Integral Image Frame Buffer Setup:
   //  Theory: 
   //    Two parallel buffers were implemented for integral image (ii) and integral image square (iix2).
   //    One buffer addresses the lower chunk of data for high bandwidth memory read while the other buffer addresses the next(upper) chunk.
   //    Subwindow_top.vhd addresses these chunks based on subwindow(0)'s relative position in the scaled integral image.
   //    16 subwindow's are currently implemented, so each buffer data output width is 16*wordSize; where wordSize is 21bit for ii and 29bit for iix2.
   //    Each subwindow instance is offset by 1 pixel in the X direction, relative to the integral image.
   //    These chunks are adjacent in memory and allow a large mux like entity to route any 16*wordSize data set from these two addressed chunks.
   //    
   //    Subwindow_top.vhd generates a 13bit address where the upper 9bits are used to address the integral image buffers
   //    and the lower 4bits are used as select signals for the large data mux routing.
   //
   //    This type of memory architecture eliminates the need to access the memory twice to access data for the 16 subwindows,
   //    but comes at the cost of doubling the amount of memory needed for integral image buffering. 
   //
   //    An example data access: 
   //      If subwindow(0) requires the data stored at pixel location x=3,y=0, then subwindow(1) will receive the data from x=4,y=0
   //      and subwindow(15) will receive the data from x=18,y=0.
   //      So the upper 9 bits of the generated ii_rdaddress, within subwindow_top.vhd, will be zero
   //      to address the first 16 words in memory via the lower chunk buffer and the following 16 words via the upper chunk buffer.
   //      The lower 4 bits of the generated ii_rdaddress are used to select which 16 words are routed to the subwindows.
   //      Since the addressed pixel location was x=3,y=0, word(3):word(18) are routed to subwindow(0):subwindow(15) respectively.
   //    
   //    It should also be noted that each integral image buffer is divided into two partitions. These are upper and lower partitions within the same
   //    addressable RAM entity. The division of each integral image buffer allows one portion to be written to by the integral image generator process
   //    while the other can be read from by the subwindow process. In this implementation, a buffer contains two 39*59 pixel integral images in the same buffer.
   //    Each buffer contains 8,192 addressable memory locations and the MSbit of the 13bit address determines if the lower or upper memory partitions is being operated on.
   //    So effectively 0(dec) is the base address of the lower memory partitions and 4,096(dec) is the base address of the upper memory partitions.
   //    In the top level, the mem_state signal determines which partitions of the integral image memory space is being written to by ii_gen and read from subwindow_top.
   //      mem_state='0' ... lower memory partition is being written to while the upper is being read
   //      mem_state='1' ... upper memory partition is being written to while the lower is being read
   //
   //    But how does this memory architecture impact the system performance? This architecture allows the current subwindow classifier cascade to execute while the next
   //    integral image to be evaluated is generated. The ii_gen process is always completed before the parallel subwindows can scan through the 36 possible scan locations
   //    within the current integral image. So performance is effectively the same as buffer that contains the integral image of the entire scaled image.
   //    
   //  buffer1:
   //    write portA : ii_gen
   //    write portB : GND
   //    read portA : ii_gen
   //    read portB : subwindow_top, lower data chunk //width=(16 * wordSize)
   //  buffer2:
   //    write portA : ii_gen
   //    write portB : GND
   //    read portA : OPEN
   //    read portB : subwindow_top, upper data chunk //width=(16 * wordSize)
   		// lower 16 words in 32 word chunk
   ii_buffer ii_ram1(
      .addra(address_buff_2A),
      .addrb(address_buff_2B),
      .clka(clk_iigen),
      .wea(1'b1),
      .web(1'b1),
      .clkb(clk_sys),
      .dina(wrdata_buff_2A),
      .dinb(1'b0),
      .ena(wren_buff_2A),
      .enb(1'b0),
      .douta(rddata_buff_2A),
      .doutb(rddata_buff_2B[(16 * 20 * 1) - 1:0])
   );
   
   assign address_buff_2B_prime = address_buff_2B + 9'd1;
   		// upper 16 words in 32 word chunk
   ii_buffer ii_ram2(
      .addra(address_buff_2A),
      .addrb(address_buff_2B_prime),
      .clka(clk_iigen),
      .wea(1'b1),
      .web(1'b1),
      .clkb(clk_sys),
      .dina(wrdata_buff_2A),
      .dinb(9'b0),
      .ena(wren_buff_2A),
      .enb(1'b0),
      .douta(),
      .doutb(rddata_buff_2B[(16 * 20 * 2) - 1:(16 * 20 * 1)])
   );
   
   		// lower 16 words 32 word chunk
   iix2_buffer iix2_ram1(
      .addra(address_buff_3A),
      .addrb(address_buff_3B),
      .clka(clk_iigen),
      .clkb(clk_sys),
      .wea(1'b1),
      .web(1'b1),
      .dina(wrdata_buff_3A),
      .dinb(9'b0),
      .ena(wren_buff_3A),
      .enb(1'b0),
      .douta(rddata_buff_3A),
      .doutb(rddata_buff_3B[(16 * 28 * 1) - 1:0])
   );
   
   assign address_buff_3B_prime = address_buff_3B + 9'd1;
   		// upper 16 words 32 word chunk
   iix2_buffer iix2_ram2(
      .addra(address_buff_3A),
      .addrb(address_buff_3B_prime),
      .clka(clk_iigen),
      .clkb(clk_sys),
      .wea(1'b1),
      .web(1'b1),
      .dina(wrdata_buff_3A),
      .dinb(9'b0),
      .ena(wren_buff_3A),
      .enb(1'b0),
      .douta(),
      .doutb(rddata_buff_3B[(16 * 28 * 2) - 1:(16 * 28 * 1)])
   );
   
   // buffer mux's 
   
   mux_std_logic clk_buff_1A_mux(
      .sel(buff_1A_mux_sel),
      .a(pixclk),
      .b(clk_faceBox),
      .q(clk_buff_1A)
   );
   
   
   mux_std_logic clk_buff_1B_mux(
      .sel(buff_1B_mux_sel),
      .a(ov7670_pclk),
      .b(clk_iigen),
      .q(clk_buff_1B)
   );
   
   
   mux_2_1 #(17) address_buff_1A_mux(
      .sel(buff_1A_mux_sel),
      .a(image_rdaddress_from_addr_gen),		// VGA address gen
      .b(image_wraddress_from_faceBox),		// faceBox address gen
      .q(address_buff_1A)
   );
   
   
   mux_2_1 #(17) address_buff_1B_mux(
      .sel(buff_1B_mux_sel),
      .a(image_wraddress_from_ov7670_capture),		// camera address gen
      .b(image_rdaddress_from_iigen),		// ii_gen address gen
      .q(address_buff_1B)
   );
   
   // ii_gen process
   
   ii_gen ii_gen_inst(
      .clk(clk_iigen),
      .reset(ii_gen_reset_s),
      .start(ii_gen_start_s),
      .image_data_i(rddata_buff_1B),
      .image_scale(scale_count),
      .ii_data_i(rddata_buff_2A),
      .iix2_data_i(rddata_buff_3A),
      .mem_state(mem_state),
      .scaleImg_x_base(ii_gen_x_base),
      .scaleImg_y_base(ii_gen_y_base),
      .image_rdaddress(image_rdaddress_from_iigen),
      .ii_address(address_buff_2A),
      .ii_wren(wren_buff_2A),
      .ii_data_o(wrdata_buff_2A),
      .iix2_data_o(wrdata_buff_3A),
      .done(ii_gen_done_s)
   );
   assign address_buff_3A = address_buff_2A;		// same address for ii and iix2 ii_gen process
   assign wren_buff_3A = wren_buff_2A;		// same wren for ii and iix2 ii_gen process
   
   // subwindow top level
   
   subwindow_top subwin_top_inst(
      .reset(subwin_reset_s),
      .clk_sys(clk_sys),
      .start(subwin_start_s),
      .mem_state(mem_state),
      .x_pos_subwin0(subwin_x_base_offset),
      .y_pos_subwin0(subwin_y_base_offset),
      .ii_rddata(rddata_buff_2B),
      .iix2_rddata(rddata_buff_3B),
      .ii_rdaddress(address_buff_2B),
      .iix2_rdaddress(address_buff_3B),
      .fail_out(subwin_fail_s),
      .done(subwin_done_s)
   );
   
   // calculate x and y position of subwindow0 within the scaled image
   //   Depends on:
   //    (1) current integral image location relative to the scaled image
   //    (2) subwindow location relative to the integral image
   assign subwin_x_pos = (subwin_x_base + subwin_x_base_offset);
   assign subwin_y_pos = (subwin_y_base + subwin_y_base_offset);
   
   // faceBox buffer/process
   //   only write to faceBox buffer when the cascade is done and there is at least one subdinow that contains a face
   assign faceBox_wren = subwin_done_s & (~subwin_all_fail);
   
   faceBox faceBox_inst(
      .reset(faceBox_reset_s),
      .clk_subwin(clk_sys),
      .clk_faceBox(clk_faceBox),
      .start_draw(faceBox_start_s),
      .scale(scale_count),
      .x_pos_subwin(subwin_x_pos),
      .y_pos_subwin(subwin_y_pos),
      .subwin_done(faceBox_wren),
      .subwin_detection(subwin_fail_s),
      .img_wraddress(image_wraddress_from_faceBox),
      .img_wrdata(image_wrdata_from_faceBox),
      .img_wren(image_wren_from_faceBox),
      .done_draw(faceBox_done_s)
   );
   
   // debug and performance related
   
   always @(posedge	clk_faceBox)
   begin
      if (faceBox_done_s == 1'b1)
         measure_performance_reg <= ~measure_performance_reg;
   end
   // toggles after every faceBox process completion 
   // half period on o-scope indicates the processed FPS
   assign measure_performance = measure_performance_reg;
   
   assign ii_gen_done = ii_gen_done_s;		// debug
   assign subwin_done = subwin_done_s;		// debug
   assign faceBox_done = faceBox_done_s;		// debug
   
endmodule
`undef component_package

