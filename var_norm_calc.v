//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? ?? 29 2018 17:22:50
//
//      Input file      : 
//      Component name  : var_norm_calc
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module var_norm_calc(
   clk,
   p0,
   p1,
   p2,
   p3,
   ssp0,
   ssp1,
   ssp2,
   ssp3,
   var_norm_factor
);
   input         clk;
   input [19:0]  p0;		// unsigned
   input [19:0]  p1;		// unsigned
   input [19:0]  p2;		// unsigned
   input [19:0]  p3;		// unsigned
   input [27:0]  ssp0;		// unsigned
   input [27:0]  ssp1;		// unsigned
   input [27:0]  ssp2;		// unsigned
   input [27:0]  ssp3;		// unsigned
   output [21:0] var_norm_factor;		// signed??
   reg [21:0]    var_norm_factor;
   
   
   wire [20:0]   result_add0;		// MSbit is carry from add0
   wire [20:0]   result_add1;		// MSbit is carry from add1
   wire [20:0]   result_sub0;
   wire [41:0]   result_mult0;
   wire [42:0]   result_mult0_extend;
   
   wire [28:0]   result_add2;		// MSbit is carry from add0
   wire [28:0]   result_add3;		// MSbit is carry from add1
   wire [28:0]   result_sub1;
   
   wire [28:0]   result_divide0;
   wire [42:0]   result_divide0_extend;
   
   wire [43:0]   result_sub2;		//MSB is ...
   wire          result_sub2_cout;		//
   
   wire [21:0]   result_sqrt0;
   
   //------------ m -----------------------------
   
   assign result_add0 = (({1'b0, p0}) + ({1'b0, p3}));
   
   assign result_add1 = (({1'b0, p1}) + ({1'b0, p2}));
   
   assign result_sub0 = (result_add0 - result_add1);
   
   //------------ m^2 ---------------------------
   
   assign result_mult0 = (result_sub0 * result_sub0);
   
   assign result_mult0_extend[42] = 1'b0;		// always positive
   assign result_mult0_extend[41:0] = result_mult0;
   
   //------------ sum(x^2) ----------------------
   
   assign result_add2 = (({1'b0, ssp0}) + ({1'b0, ssp3}));
   
   assign result_add3 = (({1'b0, ssp1}) + ({1'b0, ssp2}));
   
   assign result_sub1 = (result_add2 - result_add3);
   
   //------------ sum(x^2)/n --------------------
   
   //instead of divide by 24*24=576, so divide by 512 by shift right logical ... IN>>9=OUT
   // result_sub1 is 29bit unsigned
   // result_divide0 is 29bit
   assign result_divide0[28:20] = 9'b0;
   assign result_divide0[19:0] = result_sub1[28:9];
   
   // extend result_divide0 -- always positive ... extended bits are all zero for signed vale
   assign result_divide0_extend[42:29] = 14'b0;
   assign result_divide0_extend[28:0] = result_divide0;
   
   //------------ m^2 - sum(x^2)/n --------------
   
   assign result_sub2[42:0] = (result_mult0_extend - result_divide0_extend);		//no cout implementation needed
   
   //------------ sqrt(m^2 - sum(x^2)/n) --------
   
   // 44 bit unsigned sqrt, latancy of 11 clock cycles
   
   altsqrt_variancecalc sqrt0_inst(
      .aclk(clk), 
      .s_axis_cartesian_tvalid(1'b1),
      .s_axis_cartesian_tdata(result_sub2),
      .m_axis_dout_tdata(result_sqrt0),
      .m_axis_dout_tvalid()
   );
   
   //------------ sqrt mux --------------
   
   assign result_sub2[43] = result_sub2[42];		// should always be positive ???
   
   
   always @(posedge clk)
   begin
      if (result_sub2[43] == 1'b0)
         var_norm_factor <= result_sqrt0;
      else
         var_norm_factor <= 1;		// (integer value, bit width)
   end
   
endmodule
